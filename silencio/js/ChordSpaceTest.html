<html>
<head>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<script src='csound_loader.js'></script>
<script src='sprintf.js'></script>
<script src='numeric.js'></script>
<script src="three.js"></script>
<script src='tinycolor.js'></script>
<script src='Silencio.js'></script>
<script src="TrackballControls.js"></script>
<script src='ChordSpace.js'></script>
<script src='numeric.js'></script>
<script src='HarmonyIFS.js'></script>
<script src="dat.gui.js"></script>
</head>
<body>
<H1>ChordSpace Tests</H1>
<script>
  function wryte(source) {
    document.write('<h3>Source</h3>');
    document.write('<pre>'+ source + '</pre>');
    console.log("SOURCE:");
    console.log(source);
    var result = eval(source);
    document.write('<h3>Result</h3>');
    document.write('<pre>' + result + '</pre>');
    console.log("RESULT:");
    console.log(result);
  }
  function test(title, source) {
    document.write('<h2>' + title + '</h2>');
    wryte(source);
  }
console.log("This is console.log.");
console.info("This is console.info.");
console.warn("This is console.warn.");
console.error("This is console.error.");
console.assert(false, "This is console.assert.");
let v1 = new ChordSpace.Chord([0, 3, 7]);
v1.iseV()
let v2 = new ChordSpace.Chord([0, 4, 9]);
v2.iseV();
let v3 = new ChordSpace.Chord([0, 5, 8]);
v3.iseV();
let test_chord;
let test_is_opti;
test_chord = new ChordSpace.Chord([-6, -6, 6, 6]);
is_opti = test_chord.iseOPTTI();
// Should not pass.
test_chord = new ChordSpace.Chord([-3, -2, 8]);
is_opti = test_chord.iseOPTTI();
test("There should be 19 chords in OPTTI for trichords", '');
let opti_3 = ChordSpace.allOfEquivalenceClass(3, 'OPTTI');
test("There should be 83 chords in OPTTI for tetrachords", '');
//let opti_4 = ChordSpace.allOfEquivalenceClass(4, 'OPTTI');
console.log("EOP OF MINOR TRIADS")
mt = new ChordSpace.Chord([0, 3, 7]);
for (i = 0; i < 12; i++) {
    let triad = mt.T(i);
    let triad_eop = triad.eOP();
    let triad_eop_ett = triad_eop.eTT();
    console.log(sprintf("minor triad:    %s type: %s iseV: %s sum: %s", triad.toString(), triad.chord_type().toString(), triad.iseV(), triad.sum()));
    console.log(sprintf("    eop:        %s type: %s iseV: %s sum: %s", triad_eop.toString(), triad_eop.chord_type().toString(), triad_eop.iseV(), triad_eop.sum()));
    console.log(sprintf("    ett of eop: %s type: %s iseV: %s sum: %s", triad_eop_ett.toString(), triad_eop_ett.chord_type().toString(), triad_eop_ett.iseV(), triad_eop_ett.sum()));
}
  
test('factorial', 'ChordSpace.factorial(8)');
test('EPSILON', 'ChordSpace.EPSILON');
test('eq_epsilon', 'ChordSpace.eq_epsilon(1,1.00000000000001)');
test('eq_epsilon', 'ChordSpace.eq_epsilon(1,1.00000001)');
test('gt_epsilon', 'ChordSpace.gt_epsilon(1.00000000000001, 1)');
test('gt_epsilon', 'ChordSpace.gt_epsilon(1.00000001, 1)');
test('lt_epsilon', 'ChordSpace.lt_epsilon(1.00000000000001, 1)');
test('lt_epsilon', 'ChordSpace.lt_epsilon(1.00000001, 1)');
test('ge_epsilon', 'ChordSpace.ge_epsilon(1.00000000000001, 1)');
test('ge_epsilon', 'ChordSpace.ge_epsilon(1.00000001, 1)');
test('le_epsilon', 'ChordSpace.le_epsilon(1.00000000000001, 1)');
test('le_epsilon', 'ChordSpace.le_epsilon(1.00000001, 1)');
test('OCTAVE', 'ChordSpace.OCTAVE');
test('T', 'ChordSpace.T(5, 5)');
test('I', 'ChordSpace.I(5)');
var chord = new ChordSpace.Chord();
chord.resize(5);
test('New chord', 'chord.toString()');
chord.setPitch(1, 2);
chord.setPitch(3, 2);
test('count', 'chord.count(2)');
a = new ChordSpace.Chord();
a.resize(4);
b = a.T(1);
test('Chord.eq_epsilon', 'a');
wryte('b');
test('a.eq_epsilon(b)');
test('Chord.lt_epsilon', 'a.lt_epsilon(b)');
test('Chord.le_epsilon', 'a.le_epsilon(b)');
test('Chord.hash', 'chord.hash()');
test('Chord.contains', 'chord.contains(5)');
test('Chord.contains', 'chord.contains(0)');
test('Chord.min', 'chord.min()');
test('Chord.minimumInterval', 'chord.minimumInterval()');
test('Chord.max', 'chord.max()');
test('Chord.maximumInterval', 'chord.maximumInterval()');
clone = chord.clone();
test('Chord.clone', 'chord.clone()');
test('Chord.floor', 'chord.floor()');
test('Chord.ceil', 'chord.ceil()');
test('Chord.origin', 'chord.origin()');
b.setPitch(0, 5);
a.setPitch(3, 7);
test('Euclidean distance', 'ChordSpace.euclidean(a, b)');
test('Chord.distanceToOrigin', 'chord.distanceToOrigin()');
test('Chord.sum', 'chord.sum()');
test('Chord.distanceToUnisonDiagonal', 'chord.distanceToUnisonDiagonal()');
trichord = new ChordSpace.Chord();
trichord.resize(3);
test('Chord.maximallyEven', 'chord.maximallyEven(1)');
wryte('trichord.maximallyEven(1)');
test('Chord.T', 'chord.T(1)');
test('Chord.I', 'chord.I()');
wryte('trichord.I(6)');
test('ChordSpace.modulo',  'ChordSpace.modulo(  7,  3)');
wryte('ChordSpace.modulo(-7,  3)');
wryte('ChordSpace.modulo( 7, -3)');
wryte('ChordSpace.modulo(-7, -3)');
wryte('ChordSpace.modulo(-7, 12)');
wryte('ChordSpace.modulo( 7+12, 12)');
wryte('ChordSpace.modulo(-7, 12)');
wryte('ChordSpace.modulo(-7-12, 12)');
test('ChordSpace.epc',  'ChordSpace.epc(7)');
wryte('ChordSpace.epc(12+7)');
test('Chord.isepcs',  'chord.isepcs()');
wryte('chord.T(11).isepcs()');
test('Chord.er',  'chord.T(12).er(24)');
test('Chord.epcs',  'chord.T(12).epcs()');
test('Chord.et',  'chord.T(12).et()');
test('Chord.iset',  'chord.T(12).iset()');
wryte('chord.iset()');
test('Chord.iseR',  'chord.T(12).iseR(12)');
wryte('chord.iseR(12)');
test('Chord.iseO',  'chord.T(12).iseO()');
wryte('chord.iseO()');
test('Chord.eR',  'chord.T(12).eR(24)');
wryte('chord.T(12).eR(12)');
wryte('chord.eR(12)');
test('Chord.eO',  'chord.T(12).eO()');
test('Chord.iseP',  'chord.iseP()');
test('Chord.eP',  'chord.eP()');
test('Chord.iseT',  'chord.T(12).iseT()');
wryte('chord.iseT()');
test('Chord.eT',  'chord.eT()');
test('Chord.eTT',  'chord.eTT()');
test('Chord.iseTT',  'chord.iseTT()');
test('Chord.iseI',  'chord.iseI()');
test('Chord.eI',  'chord.eI()');
test('Chord.iseRP',  'chord.T(12).iseRP(24)');
wryte('chord.eTT().eP().iseRP(12)');
test('Chord.iseOP',  'chord.T(12).iseOP()');
wryte('chord.eTT().eP().iseOP()');
test('Chord.eRP',  'chord.T(12).eRP(24)');
test('Chord.eOP',  'chord.T(12).eOP()');
wryte('chord.eOP()');
wryte('chord.T(10).eOP()');
test('Chord.permutations',  'chord');
wryte('chord.permutations()');
test('Chord.iseV',  'chord.iseV()');
wryte('chord.cycle(-1).iseV()');
test('Chord.eV',  'chord.eV()');
test('Chord.iseRPT',  'chord.T(12).iseRPT(24)');
wryte('chord.eP().iseRPT(12)');
test('Chord.iseRPTT',  'chord.T(12).iseRPTT(24)');
wryte('chord.eP().iseRPTT(12)');
test('Chord.iseOPT',  'chord.T(12).iseOPT()');
wryte('chord.eP().iseOPT()');
test('Chord.iseOPTT',  'chord.T(12).iseOPTT()');
wryte('chord.eP().iseOPTT()');
var CM7 = new ChordSpace.Chord();
CM7.set([0, 4, 7, 11]);
test('Chord.cycle',  'CM7.cycle(1)');
wryte('CM7');
wryte('CM7.cycle(-1)');
wryte('CM7.cycle(0)');
test('Chord.v', 'CM7');
wryte('CM7.v(1)');
wryte('CM7.v(-1)');
wryte('CM7.voicings()');
test('Chord.eRPT', 'CM7.eRPT(12)');
wryte('CM7.T(3).eRPT(12)');
test('Chord.eRPTT', 'CM7.eRPTT(12)');
wryte('CM7.T(3).eRPTT(12)');
test('Chord.eOPT', 'CM7.eOPT()');
wryte('CM7.T(3).eOPT(12)');
test('Chord.eOPTT', 'CM7.eOPTT()');
wryte('CM7.T(3).eOPTT()');
test('Chord.iseOPI', 'CM7.iseOPI()');
wryte('CM7.I().iseOPI()');
test('Chord.eOPI', 'CM7.eOPI()');
wryte('CM7.I().eOPI()');
test('Chord.iseOPTI',  'CM7.T(1).iseOPTI()');
wryte('CM7.iseOPTI()');
test('Chord.iseOPTTI',  'CM7.T(1).iseOPTTI()');
wryte('CM7.iseOPTTI()');
test('Chord.eOPTI',  'CM7.T(1).eOPTI()');
wryte('CM7.I().eOPTI()');
wryte('CM7.eOPTI()');
test('Chord.eOPTTI',  'CM7.T(1).eOPTTI()');
wryte('CM7.I().eOPTTI()');
wryte('CM7.eOPTTI()');
test('Pitch-class names',  'ChordSpace.pitchClassesForNames');
wryte('ChordSpace.pitchClassesForNames["Ab"]');
wryte('ChordSpace.pitchClassesForNames["G#"]');
test('Pitch-class set names',  'ChordSpace.chordsForNames');
wryte('ChordSpace.chordsForNames["GM"]');
wryte('ChordSpace.chordsForNames["AbM9"]');
wryte('ChordSpace.chordsForNames["Em7"]');
wryte('ChordSpace.chordsForNames["G7b9#5"]');
test('Names for chords', 'ChordSpace.nameForChord(CM7.T(2))');
CM = new ChordSpace.Chord()
CM.set([0, 4, 7]);
test('P',  'ChordSpace.nameForChord(CM.nrP())');
wryte('CM.nrP().eOP()');
test('L',  'ChordSpace.nameForChord(CM.nrL())');
wryte('CM.nrL().eOP()');
test('R',  'ChordSpace.nameForChord(CM.nrR())');
wryte('CM.nrR().eOP()');
test('D',  'ChordSpace.nameForChord(CM.nrD())');
wryte('CM.nrD().eOP()');
test('Chord information',  'CM7.information()');
test('K',  'CM7.K().information()');
var minor = ChordSpace.chordForName('Cm');
var major = ChordSpace.chordForName('CM');
var CM = major.clone();
var result = CM.Q(1, minor);  
test('Q',  'CM.Q(1, minor)');
wryte('CM.Q(1, major).information()');
wryte('CM.Q(1, minor).information()');
test('J',  'CM.J(1)');
test('ChordSpace.voiceleading',  'ChordSpace.voiceleading(major,minor)');
test('ChordSpace.parallelFifth',  'ChordSpace.parallelFifth(major,minor)');
wryte('ChordSpace.parallelFifth(major.T(7),major)');
test('ChordSpace.voiceleadingSmoothness',  'ChordSpace.voiceleadingSmoothness(major,minor)');
test('ChordSpace.voiceleadingClosestRange',  'ChordSpace.voiceleadingClosestRange(major.T(12),minor.T(4),36)');
test('Chord.note',  'CM.note(2)');
test('Chord.notes',  'CM7.notes()');
var score = new Silencio.Score();
test('Chord.toScore',  'CM7.toScore(score)');
test('ChordSpace.conformPitchToChord',  'ChordSpace.conformPitchToChord(8+12,minor)');
var event = new Silencio.Event();
event.key = 24+9;
test('ChordSpace.conformToChord',  'ChordSpace.conformToChord(event, CM7)');
event.key = 24+9;
wryte('ChordSpace.conformToChord(event, CM7.T(24))');
event.key = 24+9;
wryte('ChordSpace.conformToChord(event, CM7.T(24), false)');
var c1 = CM7.T(3).K();
var c2 = CM.I(4).Q(2, minor);
ChordSpace.insert(score, c1, 2, 2);
ChordSpace.insert(score, c2, 2, 2);
ChordSpace.insert(score, c1, 2, 2);
test('Score.slice', 'score.slice(2, 3)');
test('ChordSpace.gather',  'ChordSpace.gather(score, 2, 3)');

</script>
</body>
</html>
